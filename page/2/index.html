<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">John Doe</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">前端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="#" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl twitter" target="_blank" href="#" title="twitter">twitter</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/ArrayList/" style="font-size: 10px;">ArrayList</a> <a href="/tags/C/" style="font-size: 12.5px;">C</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/FilenameFilter/" style="font-size: 10px;">FilenameFilter</a> <a href="/tags/File类/" style="font-size: 10px;">File类</a> <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/IO流其他类/" style="font-size: 10px;">IO流其他类</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/LinkedHashSet/" style="font-size: 10px;">LinkedHashSet</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/Throw/" style="font-size: 10px;">Throw</a> <a href="/tags/二十四史/" style="font-size: 17.5px;">二十四史</a> <a href="/tags/史记/" style="font-size: 15px;">史记</a> <a href="/tags/增强for循环/" style="font-size: 10px;">增强for循环</a> <a href="/tags/多线程/" style="font-size: 12.5px;">多线程</a> <a href="/tags/字符流/" style="font-size: 10px;">字符流</a> <a href="/tags/字节流/" style="font-size: 10px;">字节流</a> <a href="/tags/工具类/" style="font-size: 10px;">工具类</a> <a href="/tags/数据类型/" style="font-size: 10px;">数据类型</a> <a href="/tags/比较器/" style="font-size: 10px;">比较器</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/符号/" style="font-size: 10px;">符号</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a> <a href="/tags/递归练习/" style="font-size: 10px;">递归练习</a> <a href="/tags/集合类/" style="font-size: 17.5px;">集合类</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://luuman.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">John Doe</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">John Doe</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">前端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="twitter" target="_blank" href="#" title="twitter">twitter</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java_Exception" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/Java_Exception/" class="article-date">
      <time datetime="2018-01-15T01:00:00.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java_Exception/">异常</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="一-异常的概述和分类"><a href="#一-异常的概述和分类" class="headerlink" title="一.异常的概述和分类"></a>一.异常的概述和分类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>异常就是Java程序在运行过程中出现的错误</li>
</ul>
<h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><ul>
<li>Throwable类是异常的顶层，有两个子类Error和Exception</li>
<li>Eception分为运行时异常和编译时异常</li>
</ul>
<h3 id="JVM默认是如何处理异常的"><a href="#JVM默认是如何处理异常的" class="headerlink" title="JVM默认是如何处理异常的"></a>JVM默认是如何处理异常的</h3><ul>
<li>JVM默认是如何处理异常的<ul>
<li>main函数收到这个问题时,有两种处理方式:</li>
<li>a:自己将该问题处理,然后继续运行</li>
<li>b:自己没有针对的处理方式,只有交给调用main的jvm来处理<ul>
<li>jvm有一个默认的异常处理机制,就将该异常进行处理.</li>
<li>并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常的处理方式一"><a href="#异常的处理方式一" class="headerlink" title="异常的处理方式一"></a>异常的处理方式一</h3><ul>
<li>A:异常处理的两种方式<ul>
<li>a:try…catch…finally—–finally是用来释放资源的<ul>
<li>try catch</li>
<li>try catch finally</li>
<li>try finally </li>
</ul>
</li>
<li>b:throws</li>
</ul>
</li>
<li>B:try…catch处理异常的基本格式<ul>
<li>try{需要检测的语句}catch(可能出现的异常){异常处理语句}…finally</li>
</ul>
</li>
</ul>
<h3 id="异常的处理方式二"><a href="#异常的处理方式二" class="headerlink" title="异常的处理方式二"></a>异常的处理方式二</h3><ul>
<li>一个try跟多个catch，只要捕捉到异常就结束try…catch语句。小的要放前面，大的要放后面</li>
<li>客户端catch(Exception E),服务端一层层向上抛</li>
</ul>
<h3 id="编译期异常和运行期异常的区别"><a href="#编译期异常和运行期异常的区别" class="headerlink" title="编译期异常和运行期异常的区别"></a>编译期异常和运行期异常的区别</h3><ul>
<li>编译时异常<ul>
<li>Java程序必须显示处理，否则程序就会发生错误，无法通过编译</li>
</ul>
</li>
<li>运行时异常<ul>
<li>无需显示处理，也可以和编译时异常一样处理</li>
</ul>
</li>
</ul>
<h2 id="二-Throwable的几个常见方法"><a href="#二-Throwable的几个常见方法" class="headerlink" title="二.Throwable的几个常见方法"></a>二.Throwable的几个常见方法</h2><ul>
<li>a:getMessage()<ul>
<li>获取异常信息，返回字符串。</li>
</ul>
</li>
<li>b:toString()<ul>
<li>获取异常类名和异常信息，返回字符串。</li>
</ul>
</li>
<li>c:printStackTrace()<ul>
<li>获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</li>
</ul>
</li>
</ul>
<h2 id="三-throws的方式处理异常"><a href="#三-throws的方式处理异常" class="headerlink" title="三.throws的方式处理异常"></a>三.throws的方式处理异常</h2><h3 id="throws处理方法"><a href="#throws处理方法" class="headerlink" title="throws处理方法"></a>throws处理方法</h3><ul>
<li>定义功能方法时，需要把出现的问题暴露出来让调用者去处理。</li>
<li>那么就通过throws在方法上标识</li>
<li>如果抛出的是运行时异常，则不用在调用时处理。编译时异常的抛出，必须对其处理。</li>
</ul>
<h3 id="throws和throw的区别"><a href="#throws和throw的区别" class="headerlink" title="throws和throw的区别"></a>throws和throw的区别</h3><ul>
<li>a:throws<ul>
<li>用在方法声明后面，跟的是异常类名</li>
<li>可以跟多个异常类名，用逗号隔开</li>
<li>表示抛出异常，由该方法的调用者来处理</li>
</ul>
</li>
<li>b:throw<ul>
<li>用在方法体内，跟的是异常对象名</li>
<li>只能抛出一个异常对象名</li>
<li>表示抛出异常，由方法体内的语句处理</li>
</ul>
</li>
</ul>
<h2 id="四-finally关键字的特点及作用"><a href="#四-finally关键字的特点及作用" class="headerlink" title="四.finally关键字的特点及作用"></a>四.finally关键字的特点及作用</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>被finally控制的语句体一定会执行，即使有return存在</li>
<li>特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于释放资源，在IO流操作和数据库操作中会见到</li>
</ul>
<h3 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h3><ul>
<li>final是修饰符，可以修饰类、变量、方法</li>
<li>finally是try语句里的一个语句体，不能单独使用，用来释放资源</li>
<li>finalize是一个方法，用来回收垃圾的</li>
</ul>
<h3 id="finally和return的关系"><a href="#finally和return的关系" class="headerlink" title="finally和return的关系"></a>finally和return的关系</h3><ul>
<li>finally会在return前执行</li>
<li>return会先建立好路径准备好，才会去执行finally，导致finally不会改变return的结果</li>
</ul>
<h2 id="五-异常的注意事项及如何使用异常处理"><a href="#五-异常的注意事项及如何使用异常处理" class="headerlink" title="五.异常的注意事项及如何使用异常处理"></a>五.异常的注意事项及如何使用异常处理</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</li>
<li>b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li>
<li>c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</li>
</ul>
<h3 id="如何使用异常处理"><a href="#如何使用异常处理" class="headerlink" title="如何使用异常处理"></a>如何使用异常处理</h3><ul>
<li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li>
<li>区别:<ul>
<li>后续程序需要继续运行就try</li>
<li>后续程序不需要继续运行就throws</li>
</ul>
</li>
<li>如果JDK没有提供对应的异常，需要自定义异常。</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exception/">Exception</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Throw/">Throw</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_Collection4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/Java_Collection4/" class="article-date">
      <time datetime="2018-01-15T00:00:00.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java_Collection4/">集合类(四)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="集合类-四"><a href="#集合类-四" class="headerlink" title="集合类(四)"></a>集合类(四)</h1><h2 id="一-Map集合概述和特点"><a href="#一-Map集合概述和特点" class="headerlink" title="一.Map集合概述和特点"></a>一.Map集合概述和特点</h2><h3 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h3><ul>
<li>将键映射到值的对象</li>
<li>一个映射不能包含重复的键</li>
<li>每个键最多只能映射到一个值</li>
</ul>
<h3 id="Map接口和Collection接口的不同"><a href="#Map接口和Collection接口的不同" class="headerlink" title="Map接口和Collection接口的不同"></a>Map接口和Collection接口的不同</h3><ul>
<li>Map是双列的,Collection是单列的</li>
<li>Map的键唯一,Collection的子体系Set是唯一的</li>
<li>Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效</li>
</ul>
<h3 id="Map集合的功能概述"><a href="#Map集合的功能概述" class="headerlink" title="Map集合的功能概述"></a>Map集合的功能概述</h3><ul>
<li>a:添加功能<ul>
<li>V put(K key,V value):添加元素。<ul>
<li>如果键是第一次存储，就直接存储元素，返回null</li>
<li>如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</li>
</ul>
</li>
</ul>
</li>
<li>b:删除功能<ul>
<li>void clear():移除所有的键值对元素</li>
<li>V remove(Object key)：根据键删除键值对元素，并把值返回</li>
</ul>
</li>
<li>c:判断功能<ul>
<li>boolean containsKey(Object key)：判断集合是否包含指定的键</li>
<li>boolean containsValue(Object value):判断集合是否包含指定的值</li>
<li>boolean isEmpty()：判断集合是否为空</li>
</ul>
</li>
<li>d:获取功能<ul>
<li>Set<map.entry<k,v>&gt; entrySet():</map.entry<k,v></li>
<li>V get(Object key):根据键获取值</li>
<li>Set<k> keySet():获取集合中所有键的集合</k></li>
<li>Collection<v> values():获取集合中所有值的集合·······················</v></li>
</ul>
</li>
<li>e:长度功能<ul>
<li>int size()：返回集合中的键值对的个数</li>
</ul>
</li>
</ul>
<h3 id="Map集合的遍历之键找值"><a href="#Map集合的遍历之键找值" class="headerlink" title="Map集合的遍历之键找值"></a>Map集合的遍历之键找值</h3><ul>
<li>A:键找值思路：<ul>
<li>获取所有键的集合</li>
<li>遍历键的集合，获取到每一个键</li>
<li>根据键找值</li>
</ul>
</li>
<li><p>B:案例演示</p>
<ul>
<li><p>Map集合的遍历之键找值</p>
<pre><code>HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();
hm.put(&quot;张三&quot;, 23);
hm.put(&quot;李四&quot;, 24);
hm.put(&quot;王五&quot;, 25);
hm.put(&quot;赵六&quot;, 26);

/*Set&lt;String&gt; keySet = hm.keySet();            //获取集合中所有的键
Iterator&lt;String&gt; it = keySet.iterator();    //获取迭代器
while(it.hasNext()) {                        //判断单列集合中是否有元素
    String key = it.next();                    //获取集合中的每一个元素,其实就是双列集合中的键
    Integer value = hm.get(key);            //根据键获取值
    System.out.println(key + &quot;=&quot; + value);    //打印键值对
}*/

for(String key : hm.keySet()) {                //增强for循环迭代双列集合第一种方式
    System.out.println(key + &quot;=&quot; + hm.get(key));
}
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="Map集合的遍历之键值对对象找键和值"><a href="#Map集合的遍历之键值对对象找键和值" class="headerlink" title="Map集合的遍历之键值对对象找键和值"></a>Map集合的遍历之键值对对象找键和值</h3><ul>
<li>A:键值对对象找键和值思路：<ul>
<li>获取所有键值对对象的集合</li>
<li>遍历键值对对象的集合，获取到每一个键值对对象</li>
<li>根据键值对对象找键和值</li>
</ul>
</li>
<li><p>B:案例演示</p>
<ul>
<li><p>Map集合的遍历之键值对对象找键和值</p>
<pre><code>HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();
hm.put(&quot;张三&quot;, 23);
hm.put(&quot;李四&quot;, 24);
hm.put(&quot;王五&quot;, 25);
hm.put(&quot;赵六&quot;, 26);
/*Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hm.entrySet();    //获取所有的键值对象的集合
Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = entrySet.iterator();//获取迭代器
while(it.hasNext()) {
    Entry&lt;String, Integer&gt; en = it.next();                //获取键值对对象
    String key = en.getKey();                                //根据键值对对象获取键
    Integer value = en.getValue();                            //根据键值对对象获取值
    System.out.println(key + &quot;=&quot; + value);
}*/

for(Entry&lt;String,Integer&gt; en : hm.entrySet()) {
    System.out.println(en.getKey() + &quot;=&quot; + en.getValue());
}
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="二-HashMap和Hashtable的区别"><a href="#二-HashMap和Hashtable的区别" class="headerlink" title="二.HashMap和Hashtable的区别"></a>二.HashMap和Hashtable的区别</h2><ul>
<li>HashMap和Hashtable的区别<ul>
<li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高</li>
<li>Hashtable不可以存储null键和null值,HashMap可以存储null键和null值</li>
</ul>
</li>
<li>共同点<br>  <em>都是双列集合
  </em>底层都是Hash算法</li>
</ul>
<h2 id="三-Colletions集合工具类"><a href="#三-Colletions集合工具类" class="headerlink" title="三.Colletions集合工具类"></a>三.Colletions集合工具类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>util包下，所有方法都用static修饰，构造方法被私有</li>
</ul>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><pre><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)
public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key)
public static &lt;T&gt; T max(Collection&lt;?&gt; coll)
public static void reverse(List&lt;?&gt; list)
public static void shuffle(List&lt;?&gt; list)
</code></pre><h2 id="四-泛型固定边界"><a href="#四-泛型固定边界" class="headerlink" title="四.泛型固定边界"></a>四.泛型固定边界</h2><ul>
<li>? super E—–放入一个方法中，实质是父类引用指向子类对象</li>
<li>? extend E—–放入一个集合里，实质也是父类引用指向子类对象</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Map/">Map</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具类/">工具类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合类/">集合类</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_Collection3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/14/Java_Collection3/" class="article-date">
      <time datetime="2018-01-14T00:00:00.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/Java_Collection3/">集合类(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="集合类-三"><a href="#集合类-三" class="headerlink" title="集合类(三)"></a>集合类(三)</h1><h2 id="一-set和HashSet"><a href="#一-set和HashSet" class="headerlink" title="一.set和HashSet"></a>一.set和HashSet</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul>
<li>set集合无索引、不可以存储重复、无序(存取不一致)</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>当向set集合中存储重复元素的时候返回为false</li>
<li>HashSet的间接父类AbstractCollection重写了toString方法</li>
<li>遍历HashSet集合，可以用增强for循环。只要能用迭代器迭代的，就能使用增强for循环</li>
</ul>
<h3 id="HashSet保证元素唯一性的原理"><a href="#HashSet保证元素唯一性的原理" class="headerlink" title="HashSet保证元素唯一性的原理"></a>HashSet保证元素唯一性的原理</h3><ul>
<li>1.HashSet原理<ul>
<li>我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数</li>
<li>当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象<ul>
<li>如果没有哈希值相同的对象就直接存入集合</li>
<li>如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存</li>
</ul>
</li>
</ul>
</li>
<li>2.将自定义类的对象存入HashSet去重复<ul>
<li>类中必须重写hashCode()和equals()方法</li>
<li>hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)</li>
<li>equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储</li>
</ul>
</li>
<li>3.重写hashCode()为什么是31<ul>
<li>31是质数</li>
<li>31既不大也不小</li>
<li>31是2的五次方减一    </li>
</ul>
</li>
</ul>
<h2 id="二-LinkedHashSet"><a href="#二-LinkedHashSet" class="headerlink" title="二.LinkedHashSet"></a>二.LinkedHashSet</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>LinkedHashSet本身不具备多少功能，大多数都来自它的父类</li>
<li>底层是链表实现的，是Set集合中唯一能保证怎么存就怎么取的集合对象，因为是HashSet的在子类，所以也是保证元素唯一的</li>
</ul>
<h2 id="三-TreeSet"><a href="#三-TreeSet" class="headerlink" title="三.TreeSet"></a>三.TreeSet</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>TreeSet集合是用来对元素排序的，同样它也可以保证元素的唯一</li>
<li>对元素的排序依赖Comparbale接口，需要实现Comparbale接口并重写里面的抽象方法</li>
<li>compareTo方法返回为0是只存入一个元素，返回为正数的时候怎么存怎么取，返回为负数时倒序存取</li>
<li>二叉树，小的存储于左边，大的存储于右边，等于0值存储一个元素</li>
<li>String类里重写了compareTo方法，按照字典顺序排序</li>
</ul>
<h3 id="比较器排序"><a href="#比较器排序" class="headerlink" title="比较器排序"></a>比较器排序</h3><ul>
<li>TreeSet的构造方法里有一个传入比较器的构造方法</li>
<li>比较器是一个接口，需要对象实现这个接口</li>
<li>重写比较器里的compare方法，则会调用比较器里的比较方法</li>
</ul>
<h3 id="TreeSet原理"><a href="#TreeSet原理" class="headerlink" title="TreeSet原理"></a>TreeSet原理</h3><ul>
<li>1.特点<ul>
<li>TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>a.自然顺序(Comparable)<ul>
<li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li>
<li>调用对象的compareTo()方法和集合中的对象比较</li>
<li>根据compareTo()方法返回的结果进行存储</li>
</ul>
</li>
<li>b.比较器顺序(Comparator)<ul>
<li>创建TreeSet的时候可以制定 一个Comparator</li>
<li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li>
<li>add()方法内部会自动调用Comparator接口中compare()方法排序</li>
<li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li>
</ul>
</li>
<li>c.两种方式的区别<ul>
<li>TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)</li>
<li>TreeSet如果传入Comparator, 就优先按照Comparator</li>
</ul>
</li>
</ul>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashSet/">HashSet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinkedHashSet/">LinkedHashSet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比较器/">比较器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合类/">集合类</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-史记一_01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/13/史记一_01/" class="article-date">
      <time datetime="2018-01-13T08:28:11.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/史记一_01/">五帝本纪一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="五帝本纪一"><a href="#五帝本纪一" class="headerlink" title="五帝本纪一"></a>五帝本纪一</h1><h2 id="黄帝"><a href="#黄帝" class="headerlink" title="黄帝"></a>黄帝</h2><h3 id="黄帝的简介"><a href="#黄帝的简介" class="headerlink" title="黄帝的简介"></a>黄帝的简介</h3><ul>
<li>姓名：姓公孙，名轩辕，号有熊</li>
<li>身份：有的说是有熊国的太子，也有的说是少典部落的太子。但无论是什么，他应该是继承了这个国家的。</li>
<li>特长：生下来就很聪明</li>
<li>所处的时代环境：正统的神农氏实力日衰，诸侯国互相侵伐，百姓流离失所</li>
<li>根据环境所制定的政策：训练军队，征讨诸侯。这里有个问题，他是以什么名义征讨的呢？史书先写的神农氏无力征讨，然后黄帝才去征讨，那么他应该是用神农氏的名义去征讨的。最后他被奉为天子，走的应该是挟天子令诸侯，最后取而代之的路线。</li>
<li>征讨的过程：征讨最先应该是有一部分诸侯国被打败了，决定听从神农氏的号令，有一些诸侯是不听从的，最后有一些诸侯国是观望状态的</li>
<li>最大的两个对手：1.最强的应该是蚩尤；2.其次应该是炎帝。</li>
<li>统一的过程：1.先派大将在坂泉三战炎帝，降伏炎帝。2.再从诸侯国中挑选精兵，在逐鹿大败蚩尤。3.其他诸侯国见最强的两个国家都被打败了因此全都归顺了。4.史书记载是诸侯国立了黄帝为天子，但究竟是自己取而代之还是别的情况要结合当时的风俗才能知道。</li>
<li>所辖军队：云师。军队里的官名都以云命名</li>
<li>成为天子后所建首都：逐鹿之阿。自己一辈子都在南征北讨，军营就是自己的家。</li>
<li>妻子：西陵氏的女儿，嫘祖</li>
<li>后代：一共有二十五个儿子，得到他的姓氏的有十四个。究竟什么情况下才能得到他的姓氏，这应该和当时的风俗有关。但是能得到他姓氏的应该是身份比较最贵，能力比较出众的几个。</li>
<li>继承者：自己的孙子颛顼</li>
</ul>
<h3 id="黄帝的总结"><a href="#黄帝的总结" class="headerlink" title="黄帝的总结"></a>黄帝的总结</h3><ul>
<li>黄帝的一生还是比较勤政的，戎马一生。但是也相当能生，二十五个儿子。所为强国之道，无外乎增强军事实力、任用贤能、鼓励农桑、发展经济等</li>
<li>后来的儒生时常吹嘘三皇五帝道德多么高尚，用道德来教化诸侯让诸侯过臣服，其实多半不读史书。要知道枪杆子出政权，在整个中国历史的最开端处就是这样的。黄帝的一生并没有像后来说所的用道德让人归顺，从他被尊为天子后还在南征北伐可见，他也并不是总是让人满意的，他所统治的国家也并不是毫无矛盾的。</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/二十四史/">二十四史</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二十四史/">二十四史</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/史记/">史记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-读史之始" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/13/读史之始/" class="article-date">
      <time datetime="2018-01-13T05:28:11.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/读史之始/">读史之始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="读史之始"><a href="#读史之始" class="headerlink" title="读史之始"></a>读史之始</h1><h2 id="开始的开始"><a href="#开始的开始" class="headerlink" title="开始的开始"></a>开始的开始</h2><p>就先从毛泽东的一首诗开始这个专题吧！<br>《贺新郎·读史》<br>人猿相揖别。只几个石头磨过，小儿时节。铜铁炉中翻火焰，为问何时猜得？不过几千寒热。人世难逢开口笑，上疆场彼此弯弓月。流遍了，郊原血。<br>一篇读罢头飞雪，但记得斑斑点点，几行陈迹。五帝三皇神圣事，骗了无涯过客。有多少风流人物？盗跖庄屩流誉后，更陈王奋起挥黄钺。歌未竟，东方白。</p>
<h2 id="为什么开这个专题"><a href="#为什么开这个专题" class="headerlink" title="为什么开这个专题"></a>为什么开这个专题</h2><p>二十四史是一个大部头，二十四史共计3213卷，约4000万字。假定一个人每天读一万字，一年读三百六十五万字，他需要读将近十一年才能读完一遍。开这个专题主要有以下几个目的：<br>1.督促自己每天都读一点史书，不让自己一曝十寒。<br>2.希望能从史书中学得一点智慧，毕竟一个人的生命是有限的，在有限的生命里想获得更多的智慧只能通过从前人的经历中总结经验和教训。</p>
<h2 id="读史的一点要求"><a href="#读史的一点要求" class="headerlink" title="读史的一点要求"></a>读史的一点要求</h2><p>但凡大部头的书籍，一遍往往很难收到效果，经常是前面读后面忘，因此对于二十四史的阅读对自己提出了以下几个要求：<br>1.要常读，反复读，带有各种目的的去读<br>2.每次阅读都要做好笔记，不动手不读书<br>3.要批判的读，不能尽信史书上的记载，要有自己的思考<br>4.要收集写的比较好的句子，并尽力背诵</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>读史使人明智，以史为鉴可以知兴替。一个人的生命最多不过百年，在浩浩荡荡五千年的历史长河里不过是眨眼之间，在千千万万的人里面不过是沧海一粟。在历史的浮沉和朝代的更替里，一定蕴含这某些必然的规律。去发现，去探究这些规律，是我们最终的目的。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/二十四史/">二十四史</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二十四史/">二十四史</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_Collection2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/13/Java_Collection2/" class="article-date">
      <time datetime="2018-01-13T00:00:00.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/Java_Collection2/">集合类（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="集合类（二）"><a href="#集合类（二）" class="headerlink" title="集合类（二）"></a>集合类（二）</h1><h2 id="一-ArraayList"><a href="#一-ArraayList" class="headerlink" title="一.ArraayList"></a>一.ArraayList</h2><h3 id="去除ArrayList中的重复元素"><a href="#去除ArrayList中的重复元素" class="headerlink" title="去除ArrayList中的重复元素"></a>去除ArrayList中的重复元素</h3><ul>
<li>思路：<br>  1.创建一个新集合<br>  2.用老集合迭代获取每个老集合里的元素<br>  3.判断新集合里是否包含老集合里的元素，如果不包含就将这个元素添加到新集合里</li>
</ul>
<h3 id="去除ArrayList中的重复自定义对象元素"><a href="#去除ArrayList中的重复自定义对象元素" class="headerlink" title="去除ArrayList中的重复自定义对象元素"></a>去除ArrayList中的重复自定义对象元素</h3><ul>
<li>要求：集合中有若干个对象，要将有重复成员变量的对象从集合中去除</li>
<li>思路：<br>  1.重写集合对象中过的equals（）方法，因为contais（）方法的底层依赖的是equals（）方法<br>  2.ArrayList中的remove（）方法依赖的也是equals（）方法</li>
</ul>
<h2 id="二-LinkedList中的特有功能"><a href="#二-LinkedList中的特有功能" class="headerlink" title="二.LinkedList中的特有功能"></a>二.LinkedList中的特有功能</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>底层通过链表实现的集合</li>
</ul>
<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><ul>
<li>public void addFirst(E e)及addLast(E e)—–在头部添加和在尾部添加</li>
<li>public E getFirst()及getLast()—–获取头部元素和获取尾部元素</li>
<li>public E removeFirst()及public E removeLast()—–删除头部元素和删除尾部元素</li>
<li>public E get(int index);—–获取指定索引位置的元素</li>
</ul>
<h2 id="三-栈和队列数据结构"><a href="#三-栈和队列数据结构" class="headerlink" title="三.栈和队列数据结构"></a>三.栈和队列数据结构</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><ul>
<li>特点：先进后出</li>
</ul>
<h3 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h3><ul>
<li>特点：像一根管子一样，先进先出</li>
</ul>
<h3 id="用LinkedList模拟栈数据结构"><a href="#用LinkedList模拟栈数据结构" class="headerlink" title="用LinkedList模拟栈数据结构"></a>用LinkedList模拟栈数据结构</h3><ul>
<li>思路：<br>  1.进栈的实现通过addLast（）方法<br>  2.出栈通过removeLast（）方法</li>
</ul>
<h2 id="四-泛型generic概述和基本使用"><a href="#四-泛型generic概述和基本使用" class="headerlink" title="四.泛型generic概述和基本使用"></a>四.泛型generic概述和基本使用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>定义：指定集合类能存储的对象类型。例如Collection<student>，指定了只能存入Student和Student的子类对象。</student></li>
<li>好处：<br>  1.提高了安全性<br>  2.省去了强转的麻烦</li>
<li>注意事项：<br>  1.&lt;&gt;里放的必须是引用数据类型<br>  2.前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型)<br>  3.泛型最好不要定义为Object，因为没有意义</li>
<li>泛型的由来<br>  通过Object转型问题引入<br>  早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题</li>
</ul>
<h3 id="ArrayList存储字符串和自定义对象并遍历泛型版"><a href="#ArrayList存储字符串和自定义对象并遍历泛型版" class="headerlink" title="ArrayList存储字符串和自定义对象并遍历泛型版"></a>ArrayList存储字符串和自定义对象并遍历泛型版</h3><ul>
<li>方法：<br>  ArrayList<string>  list = new ArrayList&lt;&gt;();<br>  Iterator<string> it = list.iterator();</string></string></li>
</ul>
<h2 id="五-泛型类的概述及使用"><a href="#五-泛型类的概述及使用" class="headerlink" title="五.泛型类的概述及使用"></a>五.泛型类的概述及使用</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>在创建的类上加一个泛型<t>，并将需要的成员变量和传递参数设置为T类，使得在创建对象时就规定好了类型。</t></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>public class 类名&lt;泛型类型1,…&gt;</li>
</ul>
<h2 id="六-泛型方法的概述和使用"><a href="#六-泛型方法的概述和使用" class="headerlink" title="六.泛型方法的概述和使用"></a>六.泛型方法的概述和使用</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul>
<li>把泛型定义在方法上</li>
</ul>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)</li>
<li>方法泛型最好与类上的泛型一致，如果不一致需要在方法上声明泛型</li>
<li>静态方法需要声明自己的泛型，因为静态方法随着类的加载而加载</li>
</ul>
<h2 id="七-泛型接口的概述和使用"><a href="#七-泛型接口的概述和使用" class="headerlink" title="七.泛型接口的概述和使用"></a>七.泛型接口的概述和使用</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul>
<li>把泛型定义在接口上</li>
</ul>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul>
<li>public interface 接口名&lt;泛型类型&gt;</li>
<li>class 类名 implements 接口名 &lt;具体的引用数据类型&gt;—–推荐用这种</li>
<li>class 类名<t> implements 接口名<t></t></t></li>
</ul>
<h2 id="八-泛型之通配符"><a href="#八-泛型之通配符" class="headerlink" title="八.泛型之通配符"></a>八.泛型之通配符</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul>
<li>泛型通配符&lt;?&gt;代表任意类型，如果没有明确，那么就是Object以及任意的Java类了</li>
</ul>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ul>
<li>ArrayList&lt;?&gt; list = new ArrayList<string>();—–当左边的泛型不确定时使用</string></li>
<li>? extends E—–向下限定，E及其子类</li>
<li>? super E——向上限定，E及其父类</li>
</ul>
<h2 id="九-增强for循环"><a href="#九-增强for循环" class="headerlink" title="九.增强for循环"></a>九.增强for循环</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ul>
<li>简化数组和Collection集合的遍历，底层用迭代器实现</li>
<li>好处是简化遍历</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre><code>for(元素数据类型 变量 : 数组或者Collection集合) {
    使用变量即可，该变量就是元素
}
for(int i : arr){
    System.out.println(i);
}
</code></pre><h2 id="十-三种迭代能否删除元素"><a href="#十-三种迭代能否删除元素" class="headerlink" title="十.三种迭代能否删除元素"></a>十.三种迭代能否删除元素</h2><ul>
<li>普通for循环,可以删除,但是索引要–，否则不能删除相邻的两个相同元素</li>
<li>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</li>
<li>增强for循环不能删除</li>
</ul>
<h2 id="十一-静态导入"><a href="#十一-静态导入" class="headerlink" title="十一.静态导入"></a>十一.静态导入</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><ul>
<li>import static 包名….类名.方法名;</li>
<li>可以直接导入到方法的级别</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>方法必须是静态的,如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。</li>
</ul>
<h2 id="十二-可变参数"><a href="#十二-可变参数" class="headerlink" title="十二.可变参数"></a>十二.可变参数</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><ul>
<li>定义方法的时候不知道该定义多少个参数</li>
</ul>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><ul>
<li>修饰符 返回值类型 方法名(数据类型…  变量名){}</li>
<li>例如：public void print(int…arr){};</li>
</ul>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>这里的变量其实是一个数组</li>
<li>如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。如：(int x,int…arr)</li>
</ul>
<h2 id="十三-Arrays工具类的asList-方法"><a href="#十三-Arrays工具类的asList-方法" class="headerlink" title="十三.Arrays工具类的asList()方法"></a>十三.Arrays工具类的asList()方法</h2><ul>
<li>List()方法可以将数组转换为List类型的集合</li>
<li>数组转集合后虽然不能添加元素，但可以使用集合里的其他方法</li>
<li>基本数据类型转换为集合时，会将整个数组作为一个元素转为集合</li>
<li>将数组转化为集合，数组必须是引用数据类型<br>*当集合转换为数组时，如果数组的长度《集合的size时，转换后的数组长度等于集合的长度，反之会自动填充默认值</li>
</ul>
<h2 id="十四-ArrayList中嵌套ArrayList"><a href="#十四-ArrayList中嵌套ArrayList" class="headerlink" title="十四.ArrayList中嵌套ArrayList"></a>十四.ArrayList中嵌套ArrayList</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul>
<li>ArrayList<arraylist<person>&gt; list = new ArrayList&lt;&gt;();</arraylist<person></li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ArrayList/">ArrayList</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinkedList/">LinkedList</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/增强for循环/">增强for循环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/泛型/">泛型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合类/">集合类</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Clang_Signs" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/12/Clang_Signs/" class="article-date">
      <time datetime="2018-01-12T11:00:00.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/Clang_Signs/">C语言符号</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="C语言符号"><a href="#C语言符号" class="headerlink" title="C语言符号"></a>C语言符号</h1><h2 id="一、操作符"><a href="#一、操作符" class="headerlink" title="一、操作符"></a>一、操作符</h2><h3 id="1-基本操作符"><a href="#1-基本操作符" class="headerlink" title="1.基本操作符"></a>1.基本操作符</h3><ul>
<li>算数操作符<ul>
<li>A.包含 ：+、-、*、/、%</li>
<li>B.注意：%取模要求两边都是整型数据</li>
</ul>
</li>
<li>位运算符<ul>
<li>A.包含：《、》、&amp;与、|或、^异或、-非</li>
<li>B.注意：移位操作符适用于整型不适用于浮点数，其中符号位被移走后会按原来的正负补符号位。 </li>
</ul>
</li>
<li>赋值<ul>
<li>包含：= 、+ - * / %= 、&amp; | ^ = 、》=</li>
</ul>
</li>
<li>单目操作符<ul>
<li>包含：！非、++、–、-负、+正、&amp;取地址、*解引用</li>
<li>解引用：他的意思是直接去寻找指针所指的地址里面的内容，此内容可以是任何数据类型，当然也可以是指针  </li>
</ul>
</li>
<li>关系操作符</li>
<li>逻辑操作符（&amp;&amp;和||具有短路效果）</li>
<li>条件操作符（？：）<ul>
<li>注意：C语言里的三目运算符号后可以有操作条件表达式，JAVA只允许有改变值的操作。</li>
</ul>
</li>
<li>逗号操作符<ul>
<li>A.定义：逗号作为运算符使用时时一个双目运算符，其运算优先级是所有运算符中最低的。</li>
<li>B.注意：a=2*6,a-4,a+15—最后的结果a=12,虽然后面的值算出来了但是没有赋值给a</li>
<li>a=(a=5+1,a+2,a+3);最后的结果为6、8、9，a=9 </li>
</ul>
</li>
</ul>
<h3 id="2-贪心法与优先级"><a href="#2-贪心法与优先级" class="headerlink" title="2.贪心法与优先级"></a>2.贪心法与优先级</h3><ul>
<li>贪心法<ul>
<li>解释:每个字符应该包含更多的字符。也就是说，编译器将程序分解成符号的方法是，从左到右一个字符一个字符的读入，如果该字符可能组成一个符号，就再读入下一个字符，判断已经读入的两个字符组成的字符串是否可能是一个符号的组成部分；如果可能，继续读入下一个字符，重复上述判断，直到读入的字符组成的字符串不再可能组成一个有意义的符号。这种处理方法，又称为“贪心法”，或者“大嘴法””。</li>
<li>例子：temp = a—b；等价于temp = （a–）-b</li>
</ul>
</li>
<li>优先级<ul>
<li>口诀：括号成员第一;<a href=""></a> 成员运算符.  -&gt;<pre><code>全体单目第二;++、 --、 +(正)、 -(负) 、指针运算*、&amp;
乘除余三,加减四;
移位五，关系六; &lt;&lt; &gt;&gt; ，关系：&gt; &lt; &gt;= &lt;=
等于(与)不等排第七;即== 和!=
位与异或和位或;位与(&amp;)异或(^)位或(|)    
三分天下&quot;八九十;  
逻辑或跟与;逻辑运算符:|| 和 &amp;&amp;
十二和十一;优先级(||)  底于 优先级(&amp;&amp;) 
条件高于赋值, 三目运算符优先级排到13 位只比赋值运算符和&quot;,&quot;高
逗号运算级最低!
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="二、表达式求值"><a href="#二、表达式求值" class="headerlink" title="二、表达式求值"></a>二、表达式求值</h2><h3 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1.隐式类型转换"></a>1.隐式类型转换</h3><ul>
<li>C在以下四种情况下会进行隐式转换:<ul>
<li>1、算术运算式中，低类型能够转换为高类型。</li>
<li>2、赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。</li>
<li>3、函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。</li>
<li>4、函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。 </li>
</ul>
</li>
<li>有符号数与无符号数之间运算问题：<ul>
<li>当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型</li>
</ul>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C语言学习/">C语言学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/符号/">符号</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Clang_DataFormat" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/12/Clang_DataFormat/" class="article-date">
      <time datetime="2018-01-12T10:00:00.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/Clang_DataFormat/">C语言中的数据类型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="C语言中的数据类型"><a href="#C语言中的数据类型" class="headerlink" title="C语言中的数据类型"></a>C语言中的数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul>
<li>short、int、long</li>
<li>有的还有编译器还支持longlong数据类型</li>
<li>可以用sizeof()函数查看每种数据类型所占的字节大小，一般只能保证short《int《long</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li>float、double</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul>
<li>char</li>
</ul>
<h2 id="空数据类型"><a href="#空数据类型" class="headerlink" title="空数据类型"></a>空数据类型</h2><ul>
<li>void 代表返回值为空或者 void-代表无类型指针，可以指向任何类型的数据。</li>
</ul>
<h2 id="数组数据类型"><a href="#数组数据类型" class="headerlink" title="数组数据类型"></a>数组数据类型</h2><ul>
<li>数组初始化的几种方式</li>
<li>int arr[10] ———生成一个大小为10的int数组</li>
<li>int arr[value] = {0,1,1,2,3…}—–生成一个含有指定数据的数组,{}里的元素个数不能多于value，不足的将会填充为0.如果省略value将生成{}内个数大小的数组。</li>
<li>int arr[5] = {0}———arr里的5个元素都是0。</li>
<li>int arrs[][5]———行数可以省略，但是列数不能省略。显示初始化建议用｛｛｝，｛｝｝的方式。</li>
</ul>
<h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li></li>
<li>结构体的定义——先定义结构体，再定义结构体变量；定义结构体的同时定义结构体变量。</li>
<li>结构体赋值——整体赋值用｛｝或者逐个成员赋值。</li>
<li>结构体的成员访问—–结构体名.成员名。</li>
<li>结构体套结构体的成员访问—–逐级访问：外结构体名.内结构体名.成员名</li>
<li>结构体的自引用—-使用指针方法、使用typedef方法。</li>
<li>结构体的相互引用—-使用不完全声明方法。</li>
<li>结构体的位域—–有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bs     <span class="comment">//结构体data是一个占2个字节的位域，其中a占8位、b占2位....</span></div><div class="line">&#123;     </div><div class="line"><span class="keyword">int</span> a:<span class="number">8</span>;     </div><div class="line"><span class="keyword">int</span> b:<span class="number">2</span>;     </div><div class="line"><span class="keyword">int</span> c:<span class="number">6</span>;     </div><div class="line">&#125;data;</div></pre></td></tr></table></figure>
<h3 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h3><ul>
<li>1.概念—–一个内存地址可以存储不同数据类型的变量，但是只能有一个变量有具体的值</li>
<li>2.定义—–</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> Data</div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> i;</div><div class="line">   <span class="keyword">float</span> f;</div><div class="line">  <span class="keyword">char</span>  str[<span class="number">50</span>];</div><div class="line">&#125; data;</div></pre></td></tr></table></figure>
<ul>
<li>3.注意—–定义共用体占用的内存应足够存储共用体中最大的成员，如上至少占用50个字节空间的内存地址</li>
<li>4.访问—–使用，共同体名.变量名访问；如：data.i</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li>1.概念—–当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型</li>
<li><p>2.定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>3.注意：</p>
<ul>
<li>C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。</li>
<li>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</li>
<li>也可以在定义枚举类型时改变枚举元素的值；enum season {spring, summer=3, autumn, winter};</li>
</ul>
</li>
<li>4.枚举遍历<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125; s;</div><div class="line"><span class="keyword">for</span> (s = spring; s &lt;= winter; s++) &#123;    <span class="comment">// 遍历枚举元素</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"枚举元素：%d \n"</span>, s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指针数据类型"><a href="#指针数据类型" class="headerlink" title="指针数据类型"></a>指针数据类型</h2><h3 id="指针变量的定义"><a href="#指针变量的定义" class="headerlink" title="指针变量的定义"></a>指针变量的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">int</span>* p = &amp;a;<span class="comment">//p是一个指针变量，int*规定了p指向的是一个int类型的值</span></div><div class="line"><span class="keyword">int</span>* q = p;</div><div class="line"><span class="keyword">int</span>* r = *p;</div></pre></td></tr></table></figure>
<h3 id="指针变量里存取的内容分析"><a href="#指针变量里存取的内容分析" class="headerlink" title="指针变量里存取的内容分析"></a>指针变量里存取的内容分析</h3><ul>
<li>如果a的地址是0X0011，则0X0011里存储的值是5</li>
<li>p的地址是0X0022，则0X0022里存储的是a的地址值即0X0011</li>
<li>q的地址是0X0033，则0X0033里存的是p里存放的值0X0011</li>
<li>r里存的是p所指向对象里的内容，即0X0011里的内容5</li>
<li>如果是数组，因为数组名就代表了地址值，所以不用加取地址符号&amp;</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C语言学习/">C语言学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据类型/">数据类型</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_Collection1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/12/Java_Collection1/" class="article-date">
      <time datetime="2018-01-12T08:28:11.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/Java_Collection1/">集合类(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="1-集合的由来"><a href="#1-集合的由来" class="headerlink" title="1.集合的由来"></a>1.集合的由来</h2><ul>
<li>数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少。</li>
</ul>
<h2 id="2-集合与数组的区别"><a href="#2-集合与数组的区别" class="headerlink" title="2.集合与数组的区别"></a>2.集合与数组的区别</h2><ul>
<li>区别1<ul>
<li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li>
<li>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</li>
</ul>
</li>
<li>区别2<ul>
<li>数组长度是固定的,不能自动增长</li>
<li>集合的长度的是可变的,可以根据元素的增加而增长</li>
</ul>
</li>
<li>数组和集合什么时候用<ul>
<li>1,如果元素个数是固定的推荐用数组</li>
<li>2,如果元素个数不是固定的推荐用集合</li>
</ul>
</li>
<li>集合增长的实现<ul>
<li>首先创建一个10个大小的空间，超过了这个大小就重新创建一个1.5倍大小的集合，再将原来的集合拷贝过来缺点是浪费内存。</li>
</ul>
</li>
<li>集合的继承体系图<ul>
<li>单列集合的根接口—–collection</li>
<li>List接口—–有序、有索引、可以存放重复的元素<ul>
<li>ArrayList（数组实现）、LinkedList（链表实现）、Vector（数组实现） </li>
</ul>
</li>
<li>Set接口—–无序、无索引、不可以存放重复的元素<ul>
<li>HashSet（Hash算法）、TreeSet（二叉树算法） </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-Collection集合的基本功能"><a href="#3-Collection集合的基本功能" class="headerlink" title="3.Collection集合的基本功能"></a>3.Collection集合的基本功能</h2><ul>
<li>基本功能<pre><code>boolean add(E e)
boolean remove(Object o)
void clear()
boolean contains(Object o)
boolean isEmpty()
int size()
Object toArray（）-----将集合转换为数组，如果要获取每个元素的内容，需注意向下转型。
</code></pre></li>
<li>带All的功能—–传递的参数是一个集合<pre><code>boolean addAll(Collection c)
boolean removeAll(Collection c)
boolean containsAll(Collection c)
boolean retainAll(Collection c)
</code></pre></li>
</ul>
<h2 id="4-集合遍历之迭代器的使用"><a href="#4-集合遍历之迭代器的使用" class="headerlink" title="4.集合遍历之迭代器的使用"></a>4.集合遍历之迭代器的使用</h2><ul>
<li>Iterator<e> iterator() —–获取迭代器。</e></li>
<li>迭代器里的方法：<ul>
<li>hasNext判断集合中是否有元素</li>
<li>next返回迭代中的下一个元素</li>
<li>remove从集合中删除迭代器中获取的最后一个元素</li>
</ul>
</li>
</ul>
<h2 id="5-迭代器的原理和源码解析"><a href="#5-迭代器的原理和源码解析" class="headerlink" title="5.迭代器的原理和源码解析"></a>5.迭代器的原理和源码解析</h2><ul>
<li>迭代器原理<ul>
<li>迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可</li>
</ul>
</li>
<li>源码解析<ul>
<li>1,在eclipse中ctrl + shift + t找到ArrayList类</li>
<li>2,ctrl+o查找iterator()方法</li>
<li>3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口</li>
<li>4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 </li>
</ul>
</li>
</ul>
<h2 id="6-List接口特有的方法"><a href="#6-List接口特有的方法" class="headerlink" title="6.List接口特有的方法"></a>6.List接口特有的方法</h2><ul>
<li>A.List特有的方法<ul>
<li>void add(int index,E element)—–在指定位置添加元素—–0《index《size都不会报异常</li>
<li>E remove(int index)—–删除指定位置的元素</li>
<li>E get(int index)—–获取指定位置的元素</li>
<li>E set(int index,E element)—–设置指定位置的元素</li>
</ul>
</li>
</ul>
<h2 id="7-并发修改异常的产生原因和解决方法"><a href="#7-并发修改异常的产生原因和解决方法" class="headerlink" title="7.并发修改异常的产生原因和解决方法"></a>7.并发修改异常的产生原因和解决方法</h2><ul>
<li>A.产生的原因<ul>
<li>遍历的同时在增加元素，因此产生并发修改异常</li>
</ul>
</li>
<li>B.解决方法<ul>
<li>1.迭代器遍历元素，迭代器添加元素—–List可以通过使用特有的ListIterator类</li>
<li>2.集合遍历元素，集合添加   </li>
</ul>
</li>
</ul>
<h2 id="8-Vector的特有功能"><a href="#8-Vector的特有功能" class="headerlink" title="8.Vector的特有功能"></a>8.Vector的特有功能</h2><ul>
<li>特有功能<ul>
<li>public void addElement(E obj)</li>
<li>public E elementAt(int index)</li>
<li>public Enumeration elements()</li>
</ul>
</li>
</ul>
<h2 id="9-数据结构之数组和链表"><a href="#9-数据结构之数组和链表" class="headerlink" title="9.数据结构之数组和链表"></a>9.数据结构之数组和链表</h2><ul>
<li>A:数组<ul>
<li>查询快修改也快</li>
<li>增删慢</li>
</ul>
</li>
<li>B:链表<ul>
<li>查询慢,修改也慢</li>
<li>增删快</li>
</ul>
</li>
</ul>
<h2 id="10-List的三个子类的特点"><a href="#10-List的三个子类的特点" class="headerlink" title="10.List的三个子类的特点"></a>10.List的三个子类的特点</h2><ul>
<li>A:List的三个子类的特点</li>
<li><pre><code>ArrayList:
    底层数据结构是数组，查询快，增删慢。
    线程不安全，效率高。
Vector:
    底层数据结构是数组，查询快，增删慢。
    线程安全，效率低。
Vector相对ArrayList查询慢(线程安全的)
Vector相对LinkedList增删慢(数组结构)
LinkedList:
    底层数据结构是链表，查询慢，增删快。
    线程不安全，效率高。
</code></pre><ul>
<li>Vector和ArrayList的区别<pre><code>Vector是线程安全的,效率低
ArrayList是线程不安全的,效率高
</code></pre>  共同点:都是数组实现的</li>
<li>ArrayList和LinkedList的区别<pre><code>ArrayList底层是数组结果,查询和修改快
LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢
</code></pre>  共同点:都是线程不安全的</li>
</ul>
</li>
<li>B:List有三个儿子，我们到底使用谁呢?<pre><code>查询多用ArrayList
增删多用LinkedList
如果都多ArrayList
</code></pre></li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合类/">集合类</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 John Doe
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>