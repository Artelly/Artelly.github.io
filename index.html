<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">John Doe</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">前端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="#" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl twitter" target="_blank" href="#" title="twitter">twitter</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/ArrayList/" style="font-size: 10px;">ArrayList</a> <a href="/tags/C/" style="font-size: 12.5px;">C</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/FilenameFilter/" style="font-size: 10px;">FilenameFilter</a> <a href="/tags/File类/" style="font-size: 10px;">File类</a> <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/IO流其他类/" style="font-size: 10px;">IO流其他类</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/LinkedHashSet/" style="font-size: 10px;">LinkedHashSet</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/Throw/" style="font-size: 10px;">Throw</a> <a href="/tags/二十四史/" style="font-size: 17.5px;">二十四史</a> <a href="/tags/史记/" style="font-size: 15px;">史记</a> <a href="/tags/增强for循环/" style="font-size: 10px;">增强for循环</a> <a href="/tags/多线程/" style="font-size: 12.5px;">多线程</a> <a href="/tags/字符流/" style="font-size: 10px;">字符流</a> <a href="/tags/字节流/" style="font-size: 10px;">字节流</a> <a href="/tags/工具类/" style="font-size: 10px;">工具类</a> <a href="/tags/数据类型/" style="font-size: 10px;">数据类型</a> <a href="/tags/比较器/" style="font-size: 10px;">比较器</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/符号/" style="font-size: 10px;">符号</a> <a href="/tags/适配器/" style="font-size: 10px;">适配器</a> <a href="/tags/递归练习/" style="font-size: 10px;">递归练习</a> <a href="/tags/集合类/" style="font-size: 17.5px;">集合类</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://luuman.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">John Doe</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">John Doe</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">前端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="twitter" target="_blank" href="#" title="twitter">twitter</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Java_Thread2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/18/Java_Thread2/" class="article-date">
      <time datetime="2018-01-18T02:00:00.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/Java_Thread2/">多线程(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="线程-二"><a href="#线程-二" class="headerlink" title="线程(二)"></a>线程(二)</h1><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul>
<li><p>单例设计模式：保证类在内存中只有一个对象。</p>
</li>
<li><p>如何保证类在内存中只有一个对象呢？</p>
<ul>
<li>(1)控制类的创建，不让其他类来创建本类的对象。private</li>
<li>(2)在本类中定义一个本类的对象。Singleton s;</li>
<li>(3)提供公共的访问方式。  public static Singleton getInstance(){return s}</li>
</ul>
</li>
<li><p>单例写法三种：</p>
<ul>
<li><p>(1)饿汉式 开发用这种方式。—–空间换时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//饿汉式</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">	<span class="comment">//1,私有构造函数</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="comment">//2,创建本类对象</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</div><div class="line">	<span class="comment">//3,对外提供公共的访问方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"11111111111"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>(2)懒汉式 面试写这种方式。多线程存在隐患。—–时间换空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//懒汉式,单例的延迟加载模式</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">	<span class="comment">//1,私有构造函数</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="comment">//2,声明一个本类的引用</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</div><div class="line">	<span class="comment">//3,对外提供公共的访问方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(s == <span class="keyword">null</span>)</div><div class="line">			<span class="comment">//线程1,线程2</span></div><div class="line">			s = <span class="keyword">new</span> Singleton();</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"11111111111"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>(3)第三种格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton s = <span class="keyword">new</span> Singleton();<span class="comment">//final是最终的意思,被final修饰的变量不可以被更改</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><ul>
<li>Runtime类是一个单例类<ul>
<li><pre><code>Runtime r = Runtime.getRuntime();
//r.exec(&quot;shutdown -s -t 300&quot;);        //300秒后关机
r.exec(&quot;shutdown -a&quot;);                //取消关机
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h2><ul>
<li>计时器—–第一个参数是安排的任务，第二个参数是任务执行的时间，第三个参数是过多久再执行一次</li>
</ul>
<h2 id="两个线程间的通信"><a href="#两个线程间的通信" class="headerlink" title="两个线程间的通信"></a>两个线程间的通信</h2><ul>
<li>1.什么时候需要通信<ul>
<li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的</li>
<li>如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印</li>
</ul>
</li>
<li>2.怎么通信<ul>
<li>如果希望线程等待, 就调用wait()</li>
<li>如果希望唤醒等待的线程, 就调用notify();</li>
<li>这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用</li>
</ul>
</li>
<li>3.注意事项<ul>
<li>在同步代码块中，用哪个对象锁，就用哪个对象调用wait()方法</li>
<li>因为锁对象可以是任意对象，所以wait()和notify()方法定义在Object类里</li>
<li>sleep()方法需要传入参数，时间到了自动醒来。wait()方法传入参数，代表多少时间后进入等待状态</li>
<li>sleep方法不释放锁，wait方法释放锁</li>
</ul>
</li>
</ul>
<h2 id="三个或三个以上间的线程通信"><a href="#三个或三个以上间的线程通信" class="headerlink" title="三个或三个以上间的线程通信"></a>三个或三个以上间的线程通信</h2><ul>
<li>多个线程通信的问题<ul>
<li>notify()方法是随机唤醒一个线程</li>
<li>notifyAll()方法是唤醒所有线程</li>
<li>JDK5之前无法唤醒指定的一个线程</li>
<li>如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件</li>
</ul>
</li>
<li>注意事项<ul>
<li>if判断是在哪里等待哪里唤醒</li>
<li>while是循环判断，在哪里等待就在哪里判断然后唤醒</li>
</ul>
</li>
</ul>
<h2 id="JDK1-5的新特性互斥锁"><a href="#JDK1-5的新特性互斥锁" class="headerlink" title="JDK1.5的新特性互斥锁"></a>JDK1.5的新特性互斥锁</h2><ul>
<li>1.同步<ul>
<li>使用ReentrantLock类的lock()和unlock()方法进行同步</li>
</ul>
</li>
<li>2.通信<ul>
<li>使用ReentrantLock类的newCondition()方法可以获取Condition对象</li>
<li>需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法</li>
<li>不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了</li>
</ul>
</li>
</ul>
<h2 id="线程组的概述和使用"><a href="#线程组的概述和使用" class="headerlink" title="线程组的概述和使用"></a>线程组的概述和使用</h2><ul>
<li>A:线程组概述<ul>
<li>Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</li>
<li>默认情况下，所有的线程都属于主线程组。<ul>
<li>public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组</li>
<li>public final String getName()//通过线程组对象获取他组的名字</li>
</ul>
</li>
<li>我们也可以给线程设置分组<ul>
<li>1,ThreadGroup(String name) 创建线程组对象并给其赋值名字</li>
<li>2,创建线程对象</li>
<li>3,Thread(ThreadGroup?group, Runnable?target, String?name) </li>
<li>4,设置整组的优先级或者守护线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><ul>
<li>新建,就绪,运行,阻塞,死亡</li>
</ul>
<h2 id="线程池的概述和使用"><a href="#线程池的概述和使用" class="headerlink" title="线程池的概述和使用"></a>线程池的概述和使用</h2><ul>
<li>A:线程池概述<ul>
<li>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</li>
</ul>
</li>
<li>B:内置线程池的使用概述<ul>
<li>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法<ul>
<li>public static ExecutorService newFixedThreadPool(int nThreads)</li>
<li>public static ExecutorService newSingleThreadExecutor()</li>
<li>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</li>
<li>Future&lt;?&gt; submit(Runnable task)</li>
<li><t> Future<t> submit(Callable<t> task)</t></t></t></li>
</ul>
</li>
<li>使用步骤：<ul>
<li>创建线程池对象</li>
<li>创建Runnable实例</li>
<li>提交Runnable实例</li>
<li>关闭线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程程序实现的方式3"><a href="#线程程序实现的方式3" class="headerlink" title="线程程序实现的方式3"></a>线程程序实现的方式3</h2><ul>
<li>提交的是Callable</li>
<li><p>多线程程序实现的方式3的好处和弊端</p>
<ul>
<li><p>好处：</p>
<ul>
<li>可以有返回值</li>
<li>可以抛出异常</li>
</ul>
</li>
<li><p>弊端：</p>
<ul>
<li>代码比较复杂，所以一般不用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简单工厂模式概述和使用"><a href="#简单工厂模式概述和使用" class="headerlink" title="简单工厂模式概述和使用"></a>简单工厂模式概述和使用</h2><ul>
<li>A:简单工厂模式概述<ul>
<li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li>
</ul>
</li>
<li>B:优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责</li>
</ul>
</li>
<li>C:缺点<ul>
<li>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li>
</ul>
</li>
</ul>
<h2 id="工厂方法模式的概述和使用"><a href="#工厂方法模式的概述和使用" class="headerlink" title="工厂方法模式的概述和使用"></a>工厂方法模式的概述和使用</h2><ul>
<li>A:工厂方法模式概述<ul>
<li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li>
</ul>
</li>
<li>B:优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li>
</ul>
</li>
<li>C:缺点<ul>
<li>需要额外的编写代码，增加了工作量</li>
</ul>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_GUI" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/17/Java_GUI/" class="article-date">
      <time datetime="2018-01-17T08:00:00.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/Java_GUI/">GUI</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="如何创建一个窗口并显示"><a href="#如何创建一个窗口并显示" class="headerlink" title="如何创建一个窗口并显示"></a>如何创建一个窗口并显示</h2><ul>
<li>Graphical User Interface(图形用户接口)。</li>
<li><pre><code>Frame  f = new Frame(“my window”);
f.setLayout(new FlowLayout());//设置布局管理器
f.setSize(500,400);//设置窗体大小
f.setLocation(300,200);//设置窗体出现在屏幕的位置
f.setIconImage(Toolkit.getDefaultToolkit().createImage(&quot;qq.png&quot;));
f.setVisible(true);
</code></pre></li>
</ul>
<h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><ul>
<li>FlowLayout（流式布局管理器）<ul>
<li>从左到右的顺序排列。</li>
<li>Panel默认的布局管理器。</li>
</ul>
</li>
<li>BorderLayout（边界布局管理器）<ul>
<li>东，南，西，北，中</li>
<li>Frame默认的布局管理器。</li>
</ul>
</li>
<li>GridLayout（网格布局管理器）<ul>
<li>规则的矩阵</li>
</ul>
</li>
<li>CardLayout（卡片布局管理器）<ul>
<li>选项卡</li>
</ul>
</li>
<li>GridBagLayout（网格包布局管理器）<ul>
<li>非规则的矩阵</li>
</ul>
</li>
</ul>
<h2 id="窗体监听"><a href="#窗体监听" class="headerlink" title="窗体监听"></a>窗体监听</h2><h2 id="鼠标监听"><a href="#鼠标监听" class="headerlink" title="鼠标监听"></a>鼠标监听</h2><h2 id="键盘监听和键盘事件"><a href="#键盘监听和键盘事件" class="headerlink" title="键盘监听和键盘事件"></a>键盘监听和键盘事件</h2><h2 id="动作监听"><a href="#动作监听" class="headerlink" title="动作监听"></a>动作监听</h2><h2 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h2><ul>
<li>a.什么是适配器<ul>
<li>在使用监听器的时候, 需要定义一个类事件监听器接口.</li>
<li>通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐.</li>
<li>适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可.</li>
</ul>
</li>
<li>b.适配器原理<ul>
<li>适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.</li>
<li>适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的</li>
<li>目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了.</li>
</ul>
</li>
</ul>
<h2 id="需要知道的"><a href="#需要知道的" class="headerlink" title="需要知道的"></a>需要知道的</h2><ul>
<li>事件处理<ul>
<li>事件: 用户的一个操作</li>
<li>事件源: 被操作的组件</li>
<li>监听器: 一个自定义类的对象, 实现了监听器接口, 包含事件处理方法,把监听器添加在事件源上, 当事件发生的时候虚拟机就会自动调用监听器中的事件处理方法</li>
</ul>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GUI/">GUI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/适配器/">适配器</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_Thread1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/17/Java_Thread1/" class="article-date">
      <time datetime="2018-01-17T08:00:00.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/Java_Thread1/">多线程(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="线程-一"><a href="#线程-一" class="headerlink" title="线程(一)"></a>线程(一)</h1><h2 id="一-多线程概述"><a href="#一-多线程概述" class="headerlink" title="一.多线程概述"></a>一.多线程概述</h2><h3 id="多线程的引入"><a href="#多线程的引入" class="headerlink" title="多线程的引入"></a>多线程的引入</h3><ul>
<li>1.什么是线程<ul>
<li>线程是程序执行的一条路径, 一个进程中可以包含多条线程</li>
<li>多线程并发执行可以提高程序的效率, 可以同时完成多项工作</li>
</ul>
</li>
<li>2.多线程的应用场景<ul>
<li>红蜘蛛同时共享屏幕给多个电脑</li>
<li>迅雷开启多条线程一起下载</li>
<li>QQ同时和多个人一起视频</li>
<li>服务器同时处理多个客户端请求</li>
</ul>
</li>
</ul>
<h3 id="多线程并行和并发的区别"><a href="#多线程并行和并发的区别" class="headerlink" title="多线程并行和并发的区别"></a>多线程并行和并发的区别</h3><ul>
<li>并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)</li>
<li>并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。</li>
<li>比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。</li>
<li>如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。</li>
</ul>
<h3 id="Java程序运行原理和JVM的启动是多线程的吗"><a href="#Java程序运行原理和JVM的启动是多线程的吗" class="headerlink" title="Java程序运行原理和JVM的启动是多线程的吗"></a>Java程序运行原理和JVM的启动是多线程的吗</h3><ul>
<li>A:Java程序运行原理<ul>
<li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。    </li>
</ul>
</li>
<li>B:JVM的启动是多线程的吗<ul>
<li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li>
</ul>
</li>
</ul>
<h2 id="二-多线程程序实现方式"><a href="#二-多线程程序实现方式" class="headerlink" title="二.多线程程序实现方式"></a>二.多线程程序实现方式</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><pre><code>* 继承Thread，重写run()方法，将要执行的代码写入run()方法中，用start()方法调用
</code></pre><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><pre><code>* 实现Runnable接口
* 创建Thread对象, 传入Runnable
* 调用start()开启新线程
</code></pre><h3 id="实现Runnable的原理"><a href="#实现Runnable的原理" class="headerlink" title="实现Runnable的原理"></a>实现Runnable的原理</h3><ul>
<li>查看源码<ul>
<li>1,看Thread类的构造函数,传递了Runnable接口的引用 </li>
<li>2,通过init()方法找到传递的target给成员变量的target赋值</li>
<li>3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法</li>
</ul>
</li>
</ul>
<h3 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h3><ul>
<li><p>查看源码的区别:</p>
<ul>
<li>a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法</li>
<li>b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法</li>
</ul>
</li>
<li><p>继承Thread</p>
<ul>
<li>好处是:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端是:如果已经有了父类,就不能用这种方法</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的</li>
<li>弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂</li>
</ul>
</li>
</ul>
<h3 id="匿名内部类实现线程的两种方式"><a href="#匿名内部类实现线程的两种方式" class="headerlink" title="匿名内部类实现线程的两种方式"></a>匿名内部类实现线程的两种方式</h3><ul>
<li><p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread() &#123;													<span class="comment">//1,new 类()&#123;&#125;继承这个类</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;											<span class="comment">//2,重写run方法</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;							<span class="comment">//3,将要执行的代码,写在run方法中</span></div><div class="line">			System.out.println(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;										<span class="comment">//1,new 接口()&#123;&#125;实现这个接口</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;											<span class="comment">//2,重写run方法</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;							<span class="comment">//3,将要执行的代码,写在run方法中</span></div><div class="line">			System.out.println(<span class="string">"bb"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三-多线程里的方法"><a href="#三-多线程里的方法" class="headerlink" title="三.多线程里的方法"></a>三.多线程里的方法</h2><h3 id="获取名字和设置名字"><a href="#获取名字和设置名字" class="headerlink" title="获取名字和设置名字"></a>获取名字和设置名字</h3><ul>
<li>1.获取名字<ul>
<li>通过getName()方法获取线程对象的名字</li>
</ul>
</li>
<li>2.设置名字<ul>
<li>通过构造函数可以传入String类型的名字</li>
<li>通过setName(String)方法可以设置线程对象的名字</li>
</ul>
</li>
</ul>
<h3 id="获取当前线程的对象"><a href="#获取当前线程的对象" class="headerlink" title="获取当前线程的对象"></a>获取当前线程的对象</h3><ul>
<li>Thread.currentThread(), 主线程也可以获取</li>
<li>通过set方法也可以修改主线程的名字</li>
</ul>
<h3 id="休眠线程"><a href="#休眠线程" class="headerlink" title="休眠线程"></a>休眠线程</h3><ul>
<li>Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 <em> 1000 </em> 1000纳秒</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li>setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出</li>
<li>当非守护线程退出后，守护线程需要一点时间缓冲才能完全退出</li>
</ul>
<h3 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h3><ul>
<li>join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续</li>
<li>join(int), 可以等待指定的毫秒之后继续</li>
</ul>
<h3 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h3><ul>
<li>yield让出cpu—–效果不太明星</li>
</ul>
<h3 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h3><ul>
<li>setPriority()设置线程的优先级</li>
<li>最大为10，最小为1</li>
</ul>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul>
<li>1.什么情况下需要同步<ul>
<li>当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.</li>
<li>如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.</li>
</ul>
</li>
<li>2.同步代码块<ul>
<li>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</li>
<li>多个同步代码块如果使用相同的锁对象, 那么他们就是同步的</li>
</ul>
</li>
<li>3.注意事项<ul>
<li>不能用匿名对象，任意对象都可以</li>
<li>使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的</li>
<li>非静态同步函数的锁是:this</li>
<li>静态的同步函数的锁是:字节码对象</li>
</ul>
</li>
</ul>
<h2 id="四-线程安全问题"><a href="#四-线程安全问题" class="headerlink" title="四.线程安全问题"></a>四.线程安全问题</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>多线程并发操作同一数据时, 就有可能出现线程安全问题</li>
<li>使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作</li>
<li>多次启用一个线程是非法的</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁</li>
<li>尽量不要嵌套使用</li>
</ul>
<h3 id="前的线程安全的类回顾"><a href="#前的线程安全的类回顾" class="headerlink" title="前的线程安全的类回顾"></a>前的线程安全的类回顾</h3><ul>
<li>看源码：Vector,StringBuffer,Hashtable</li>
<li>Collections.synchroinzed(xxx)—–可以将某个集合变为线程安全的，这导致Vector和Hashtable的淘汰</li>
<li>Vector是线程安全的,ArrayList是线程不安全的</li>
<li>StringBuffer是线程安全的,StringBuilder是线程不安全的</li>
<li>Hashtable是线程安全的,HashMap是线程不安全的</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-史记一_03" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/17/史记一_03/" class="article-date">
      <time datetime="2018-01-17T06:28:11.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/史记一_03/">五帝本纪三</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="五帝本纪一"><a href="#五帝本纪一" class="headerlink" title="五帝本纪一"></a>五帝本纪一</h1><h2 id="虞舜"><a href="#虞舜" class="headerlink" title="虞舜"></a>虞舜</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>姓名：重华</li>
<li>身份：黄帝一系的血脉，祖上七代平民</li>
<li>性格：笃谨</li>
<li>为政举措：<ul>
<li>1.重用八恺(高阳的八个儿子)、八元(高辛的八个儿子)</li>
<li>2.流放四凶</li>
<li>3.任用二十二贤人，制定各种制度，每三年一考核</li>
<li>4.宣扬尧的美德</li>
</ul>
</li>
<li>继任者：儿子商均不肖，所以将天下禅让给了禹</li>
</ul>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><ul>
<li>舜可能是一个好天子，却不是一个好父亲。他教化了天下人，却唯独没有教化好自己的儿子，这不免可惜。三皇五帝，都称为圣人，但是他们的子孙后代有的贤能有的却凶顽，可见圣人也无法掌握很多事情。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>五帝指：黄帝、颛顼、帝喾、尧、舜。</li>
<li>国号分别为：有熊、高阳、高辛、陶唐、有虞</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/二十四史/">二十四史</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二十四史/">二十四史</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/史记/">史记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_Exercise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/17/Java_Exercise/" class="article-date">
      <time datetime="2018-01-17T01:00:00.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/Java_Exercise/">Java的一些练习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="一-统计文件夹大小"><a href="#一-统计文件夹大小" class="headerlink" title="一.统计文件夹大小"></a>一.统计文件夹大小</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><pre><code>* 从键盘接收一个文件夹路径,统计该文件夹大小
</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><pre><code>* 1.创建Scanner录入对象，获取文件夹路径
* 2.根据获得的路径创建File类
* 3.判断路径是否存在，分析该类是文件夹还是文件
* 4.如果是文件则统计文件夹大小，如果是文件夹则进入文件夹重复第三步
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code>* 1.空文件夹大小是0
* 2.文件夹是无法直接获取大小的
</code></pre><h2 id="二-删除该文件夹"><a href="#二-删除该文件夹" class="headerlink" title="二.删除该文件夹"></a>二.删除该文件夹</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><pre><code>* 从键盘接收一个文件夹路径,删除该文件夹
</code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><pre><code>* 1.创建Scanner录入对象，获取文件夹路径
* 2.根据获得的路径创建File类
* 3.判断路径是否存在，分析该类是文件夹还是文件
* 4.如果是文件则删除文件，如果是文件夹则进入文件夹重复第散三步
* 5.循环结束后删除文件夹
</code></pre><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><pre><code>* 删除不走回收站
</code></pre><h2 id="三-拷贝"><a href="#三-拷贝" class="headerlink" title="三.拷贝"></a>三.拷贝</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><pre><code>* 从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中
</code></pre><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><pre><code>* 1.创建Scanner录入对象，获取文件夹路径
* 2.根据获得的路径创建2个File类
* 3.判断路径是否存在，分析该类是文件夹还是文件
* 4.如果是文件则删除文件，如果是文件夹则进入文件夹重复第散三步
* 5.循环结束后删除文件夹
</code></pre><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><pre><code>* 文件夹不能拷贝
</code></pre><h2 id="四-按层级打印"><a href="#四-按层级打印" class="headerlink" title="四.按层级打印"></a>四.按层级打印</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><pre><code>*从键盘接收一个文件夹路径,把文件夹中的所有文件以及文件夹的名字按层级打印
</code></pre><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><pre><code>* 1.创建Scanner录入对象，获取文件夹路径
* 2.根据获得的路径创建个File类
* 3.获取所有File类下的所有文件
* 4.无论是文件还是文件夹都打印出来
* 5.设置打印层级，打印层级个\t，递归调用
</code></pre><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><pre><code>* 层级设置为0后就不要改变了，++lev和lev++都不能达到lev+1的效果
</code></pre><h2 id="五-斐波那契数列"><a href="#五-斐波那契数列" class="headerlink" title="五.斐波那契数列"></a>五.斐波那契数列</h2><h3 id="不死神兔"><a href="#不死神兔" class="headerlink" title="不死神兔"></a>不死神兔</h3><pre><code>* 故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。
* 在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡，
* 问：一对刚出生的兔子，一年内繁殖成多少对兔子?
* 1 1 2 3 5 8 13
* 第一个月一对小兔子                    1
* 第二个月一对大兔子                    1
* 第三个月一对大兔子生了一对小兔子        2
* 第四个月一对大兔子生了一对小兔子
*          一对小兔子长成大兔子            3
* 第五个月两对大兔子生两对小兔子    
*          一对小兔子长成大兔子            5
</code></pre><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><pre><code>* 方法1：arr[0] = 1,arr[1] = 1 ,arr[i] = arr[i-2] + arr[i-1]。遍历数组即可
* 方法2：递归
</code></pre><h2 id="六-1000的阶乘所有零和尾部零的个数"><a href="#六-1000的阶乘所有零和尾部零的个数" class="headerlink" title="六.1000的阶乘所有零和尾部零的个数"></a>六.1000的阶乘所有零和尾部零的个数</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><pre><code>* 方法A：用数组遍历和BigerInteger里的乘法方法做，遍历结果如果是0则count++。求尾部零，反转字符串，如果不等于0就跳出如果等于0就++。
</code></pre><h2 id="七-约瑟夫环"><a href="#七-约瑟夫环" class="headerlink" title="七.约瑟夫环"></a>七.约瑟夫环</h2><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><pre><code>* 获取幸运数字
</code></pre><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><pre><code>* 返回为int
* 参数列表为参与的数字个数
* 因为集合删除元素后自动拼接，所以用集合去做
* 每次到达集合末尾时将指针重置可以实现圆圈的效果
* 注意集合删除元素和指针的变化，需要i--
</code></pre>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/递归练习/">递归练习</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_IOStream3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/16/Java_IOStream3/" class="article-date">
      <time datetime="2018-01-16T08:00:00.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/Java_IOStream3/">IO流(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="IO流的其他类"><a href="#IO流的其他类" class="headerlink" title="IO流的其他类"></a>IO流的其他类</h1><h3 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h3><ul>
<li>1.什么是序列流<ul>
<li>序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>整合两个: SequenceInputStream(InputStream, InputStream)</li>
</ul>
</li>
<li>3.序列流整合多个<ul>
<li>SequenceInputStream(Enumeration)</li>
</ul>
</li>
</ul>
<h3 id="内存输出流"><a href="#内存输出流" class="headerlink" title="内存输出流"></a>内存输出流</h3><ul>
<li>1.什么是内存输出流<ul>
<li>该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>创建对象: new ByteArrayOutputStream()</li>
<li>写出数据: write(int), write(byte[])</li>
<li>获取数据: toByteArray()</li>
</ul>
</li>
</ul>
<h3 id="对象操作流ObjecOutputStream"><a href="#对象操作流ObjecOutputStream" class="headerlink" title="对象操作流ObjecOutputStream"></a>对象操作流ObjecOutputStream</h3><ul>
<li>1.什么是对象操作流<ul>
<li>该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>写出: new ObjectOutputStream(OutputStream), writeObject()</li>
<li>读取: new ObjectInputStream(InputStream), readObject()</li>
</ul>
</li>
<li>3.对象操作流优化<ul>
<li>将对象存储在集合中写出</li>
</ul>
</li>
<li>4.加上id号<ul>
<li>要写出的对象必须实现Serializable接口才能被序列化</li>
<li>private static final serialVersionUID—–表示版本的信息</li>
<li>不用必须加id号</li>
</ul>
</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><ul>
<li>1.什么是打印流<ul>
<li>该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式</li>
<li>System.out就是一个PrintStream, 其默认向控制台输出信息</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>打印: print(), println()</li>
<li>自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding)—–自动刷出功能只对println方法，print方法不支持</li>
<li>PrintStream和PrintWriter分别是字节打印流和字符打印流—–打印流只操作数据目的</li>
</ul>
</li>
</ul>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><ul>
<li>1.什么是标准输入输出流(掌握)<ul>
<li>System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据</li>
<li>System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据</li>
</ul>
</li>
<li>2.修改标准输入输出流(了解)<ul>
<li>修改输入流: System.setIn(InputStream)</li>
<li>修改输出流: System.setOut(PrintStream)</li>
</ul>
</li>
<li>3.两种方式实现键盘录入<ul>
<li>A.BufferedReader的readLine方法。BufferedReader br = new BufferedReader(new InputStreamReader(System.in))—–InputStreamReader转换流</li>
<li>B.Scanner</li>
</ul>
</li>
</ul>
<h3 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h3><ul>
<li>A:随机访问流概述<ul>
<li>RandomAccessFile概述</li>
<li>RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。</li>
<li>支持对随机访问文件的读取和写入。</li>
</ul>
</li>
<li>B:read(),write(),seek()—–设置位置指针</li>
</ul>
<h3 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h3><ul>
<li>1.什么是数据输入输出流<ul>
<li>DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据</li>
<li>例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>DataOutputStream(OutputStream), writeInt(), writeLong() </li>
</ul>
</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul>
<li>Properties的概述<ul>
<li>Properties 类表示了一个持久的属性集。是Hashtable的子类，是一个双列集合。通常作为配置文件存在</li>
<li>Properties 可保存在流中或从流中加载。</li>
<li>属性列表中每个键及其对应值都是一个字符串。 </li>
</ul>
</li>
<li>Properties的特殊功能<ul>
<li>public Object setProperty(String key,String value)</li>
<li>public String getProperty(String key)</li>
<li>public Enumeration<string> stringPropertyNames()</string></li>
</ul>
</li>
<li>load()和store()功能<ul>
<li>load()</li>
<li>store()—–第二个参数是对文件的描述，可以给值也可以给null</li>
</ul>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO流其他类/">IO流其他类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_IOStream2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/16/Java_IOStream2/" class="article-date">
      <time datetime="2018-01-16T01:00:00.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/Java_IOStream2/">IO流(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><ul>
<li>字符流是什么<ul>
<li>字符流是可以直接读写字符的IO流</li>
<li>字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出. </li>
</ul>
</li>
<li>FileReader类的read()方法可以按照字符大小读取</li>
<li>通过项目默认的码表，一次读取一个字符</li>
</ul>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><ul>
<li>write()方法可以自动把字符转为字节写出</li>
<li>write()中有一个2K的缓冲区，如果不关流就会把内容写到缓冲区里，关流会把内容刷新并关闭</li>
</ul>
<h3 id="什么情况下使用字符流"><a href="#什么情况下使用字符流" class="headerlink" title="什么情况下使用字符流"></a>什么情况下使用字符流</h3><ul>
<li>字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.</li>
<li>程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流</li>
<li>读取的时候是按照字符的大小读取的,不会出现半个中文</li>
<li>写出的时候可以直接将字符串写出,不用转换为字节数组</li>
</ul>
<h3 id="字符流是否可以拷贝非纯文本的文件"><a href="#字符流是否可以拷贝非纯文本的文件" class="headerlink" title="字符流是否可以拷贝非纯文本的文件"></a>字符流是否可以拷贝非纯文本的文件</h3><ul>
<li>不可以拷贝非纯文本的文件</li>
<li>因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去</li>
<li>如果是?,直接写出,这样写出之后的文件就乱了,看不了了  </li>
</ul>
<h3 id="带缓冲的字符流"><a href="#带缓冲的字符流" class="headerlink" title="带缓冲的字符流"></a>带缓冲的字符流</h3><ul>
<li>BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率</li>
<li>BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率</li>
</ul>
<h3 id="readLine-和newLine-方法"><a href="#readLine-和newLine-方法" class="headerlink" title="readLine()和newLine()方法"></a>readLine()和newLine()方法</h3><ul>
<li>属于BufferedReader和BufferedWriter里的方法</li>
<li>BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)</li>
<li>BufferedWriter的newLine()可以输出一个跨平台的换行符号”\r\n”</li>
<li>write(“\r\n”)——只支持windows系统</li>
<li>newLine()—–跨平台的</li>
</ul>
<h3 id="将文本反转"><a href="#将文本反转" class="headerlink" title="将文本反转"></a>将文本反转</h3><ul>
<li>思路<ul>
<li>用readline()读取一行</li>
<li>用Collection<string>集合去接受这一行</string></li>
<li>将集合倒着遍历并写出</li>
<li>关流时注意晚开早关</li>
</ul>
</li>
</ul>
<h3 id="LineNumberReader类"><a href="#LineNumberReader类" class="headerlink" title="LineNumberReader类"></a>LineNumberReader类</h3><ul>
<li>父类是BufferedReader，具有相同的功能, 并且可以统计行号<ul>
<li>调用getLineNumber()方法可以获取当前行号</li>
<li>调用setLineNumber()方法可以设置当前行号</li>
</ul>
</li>
</ul>
<h3 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h3><ul>
<li>获取被装饰类的引用</li>
<li>在构造方法中传入被装饰类的对象</li>
<li>对原有的功能进行升级</li>
<li>优点—–耦合性没有继承关系那么强，被装饰类的变化与装饰类的变化无关</li>
</ul>
<h3 id="用指定的码表读写字符"><a href="#用指定的码表读写字符" class="headerlink" title="用指定的码表读写字符"></a>用指定的码表读写字符</h3><ul>
<li>FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)</li>
<li>FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表)</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>函数自己调用自己</li>
<li>弊端—–调用的次数不能过多，容易导致栈内存溢出</li>
<li>好处—–不用知道循环的次数</li>
<li>构造方法不能递归调用</li>
<li>递归不一定有返回值</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字符流/">字符流</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_IOStream1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/Java_IOStream1/" class="article-date">
      <time datetime="2018-01-15T11:00:00.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java_IOStream1/">IO流(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="一-IO流概述及其分类"><a href="#一-IO流概述及其分类" class="headerlink" title="一.IO流概述及其分类"></a>一.IO流概述及其分类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>IO流用来处理设备之间的数据传输</li>
<li>Java对数据的操作是通过流的方式</li>
<li>Java用于操作流的类都在IO包中</li>
<li>流按流向分为两种：输入流，输出流。</li>
<li>流按操作类型分为两种：<ul>
<li>字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的</li>
<li>字符流 : 字符流只能操作纯字符数据，比较方便。</li>
</ul>
</li>
</ul>
<h3 id="IO流常用父类"><a href="#IO流常用父类" class="headerlink" title="IO流常用父类"></a>IO流常用父类</h3><ul>
<li>字节流的抽象父类：<ul>
<li>InputStream </li>
<li>OutputStream</li>
</ul>
</li>
<li>字符流的抽象父类：<ul>
<li>Reader </li>
<li>Writer        </li>
</ul>
</li>
</ul>
<h3 id="IO程序书写"><a href="#IO程序书写" class="headerlink" title="IO程序书写"></a>IO程序书写</h3><ul>
<li>使用前，导入IO包中的类</li>
<li>使用时，进行IO异常处理—–因为操作的是内存和硬盘之间的关系</li>
<li>使用后，释放资源</li>
</ul>
<h2 id="二-FileInputStream"><a href="#二-FileInputStream" class="headerlink" title="二.FileInputStream"></a>二.FileInputStream</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>是InputStream的子类</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>read()一次读取一个字节<ul>
<li>每次读取后指针都向后移动一位</li>
<li>到达文件末尾的时候返回为-1</li>
</ul>
</li>
<li>read()方法返回值为什么是int<pre><code>因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111
那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上
24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型
</code></pre></li>
</ul>
<h2 id="三-FileOutputStream"><a href="#三-FileOutputStream" class="headerlink" title="三.FileOutputStream"></a>三.FileOutputStream</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>是OutputStream的子类</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li>write()一次写出一个字节<ul>
<li>虽然写出的是一个int数，但是到文件上的是一个字节，会自动去出前三个八位</li>
</ul>
</li>
<li>FileOutputStream在创建对象的时候如果没有这个文件会帮我们创建出来，如果有这个文件会先把这个文件清空。如果想续写这个文件，就在第二个参数上加个true</li>
</ul>
<h2 id="四-IO流的拷贝方法"><a href="#四-IO流的拷贝方法" class="headerlink" title="四.IO流的拷贝方法"></a>四.IO流的拷贝方法</h2><h3 id="逐个字节拷贝"><a href="#逐个字节拷贝" class="headerlink" title="逐个字节拷贝"></a>逐个字节拷贝</h3><h3 id="字节数组拷贝"><a href="#字节数组拷贝" class="headerlink" title="字节数组拷贝"></a>字节数组拷贝</h3><ul>
<li>vailable()方法—–获取需要读取文件的字节个数</li>
<li>弊端:有可能会内存溢出 </li>
</ul>
<h3 id="定义小数组"><a href="#定义小数组" class="headerlink" title="定义小数组"></a>定义小数组</h3><ul>
<li>int read(byte[] b)—–返回值为b中读取到的字节个数</li>
<li>如果定义了数组，而没有添加到read里，返回的是读取字节的码表值</li>
<li>如果读取的自己个数小于数组长度，会覆盖数组前面的内容</li>
<li>write(byte[] b, int off, int len)写出有效的字节个数</li>
</ul>
<h2 id="五-BufferedInputStream和BufferOutputStream"><a href="#五-BufferedInputStream和BufferOutputStream" class="headerlink" title="五.BufferedInputStream和BufferOutputStream"></a>五.BufferedInputStream和BufferOutputStream</h2><h3 id="缓冲思想"><a href="#缓冲思想" class="headerlink" title="缓冲思想"></a>缓冲思想</h3><ul>
<li>字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，</li>
<li>这是加入了数组这样的缓冲区效果，java本身在设计的时候，</li>
<li>也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流</li>
<li>关流的时候只用关BufferedInputStream和BufferedOutputStream</li>
<li>实质是通过减少到硬盘的读写次数从而增加读写速度</li>
</ul>
<h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><ul>
<li>BufferedInputStream内置了一个缓冲区(数组)</li>
<li>从BufferedInputStream中读取一个字节时</li>
<li>BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个</li>
<li>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取</li>
<li>直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个</li>
</ul>
<h3 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h3><ul>
<li>BufferedOutputStream也内置了一个缓冲区(数组)</li>
<li>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中</li>
<li>直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里</li>
</ul>
<h3 id="小数组的读写和带Buffered的读取哪个更快"><a href="#小数组的读写和带Buffered的读取哪个更快" class="headerlink" title="小数组的读写和带Buffered的读取哪个更快?"></a>小数组的读写和带Buffered的读取哪个更快?</h3><ul>
<li>定义小数组如果是8192个字节大小和Buffered比较的话</li>
<li>定义小数组会略胜一筹,因为读和写操作的是同一个数组</li>
<li>而Buffered操作的是两个数组</li>
</ul>
<h2 id="六-flush和close方法的区别"><a href="#六-flush和close方法的区别" class="headerlink" title="六.flush和close方法的区别"></a>六.flush和close方法的区别</h2><h3 id="flush-方法"><a href="#flush-方法" class="headerlink" title="flush()方法"></a>flush()方法</h3><ul>
<li>用来刷新缓冲区的,刷新后可以再次写出</li>
</ul>
<h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><ul>
<li>用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 </li>
</ul>
<h2 id="七-字节流读写中文"><a href="#七-字节流读写中文" class="headerlink" title="七.字节流读写中文"></a>七.字节流读写中文</h2><ul>
<li>字节流读取中文的问题<ul>
<li>字节流在读中文的时候有可能会读到半个中文,造成乱码 </li>
</ul>
</li>
<li>字节流写出中文的问题<ul>
<li>字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 </li>
<li>写出回车换行 write(“\r\n”.getBytes());</li>
</ul>
</li>
</ul>
<h2 id="八-流的标准处理异常代码"><a href="#八-流的标准处理异常代码" class="headerlink" title="八.流的标准处理异常代码"></a>八.流的标准处理异常代码</h2><h3 id="1-6版本及其以前"><a href="#1-6版本及其以前" class="headerlink" title="1.6版本及其以前"></a>1.6版本及其以前</h3><ul>
<li>因为IO流是底层代码，所以异常建议抛出</li>
<li>try finally嵌套—–目的是能关一个尽量关一个</li>
</ul>
<h3 id="1-7版本"><a href="#1-7版本" class="headerlink" title="1.7版本"></a>1.7版本</h3><ul>
<li>在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉</li>
</ul>
<h2 id="九-IO流的一些例子"><a href="#九-IO流的一些例子" class="headerlink" title="九.IO流的一些例子"></a>九.IO流的一些例子</h2><h3 id="图片加密"><a href="#图片加密" class="headerlink" title="图片加密"></a>图片加密</h3><ul>
<li>写入的时候异或一个数，解密的时候再异或该数</li>
</ul>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><ul>
<li>对键盘录入的路径进行判断是不是文件</li>
<li>如果是文件则对该文件进行拷贝</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字节流/">字节流</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-史记一_02" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/史记一_02/" class="article-date">
      <time datetime="2018-01-15T08:28:11.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/史记一_02/">五帝本纪二</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="五帝本纪二"><a href="#五帝本纪二" class="headerlink" title="五帝本纪二"></a>五帝本纪二</h1><h2 id="颛顼"><a href="#颛顼" class="headerlink" title="颛顼"></a>颛顼</h2><h3 id="颛顼的简介"><a href="#颛顼的简介" class="headerlink" title="颛顼的简介"></a>颛顼的简介</h3><ul>
<li>姓名：高阳</li>
<li>身份：父亲昌意，爷爷黄帝，奶奶嫘祖</li>
<li>特点：深渊以有谋，疏通而知事</li>
<li>贡献：进一步的扩大和巩固了国土 </li>
<li>继任者：高辛—–自己的叔叔玄嚣的孙子</li>
<li>儿子：穷蝉</li>
</ul>
<h2 id="帝喾"><a href="#帝喾" class="headerlink" title="帝喾"></a>帝喾</h2><h3 id="帝喾的简介"><a href="#帝喾的简介" class="headerlink" title="帝喾的简介"></a>帝喾的简介</h3><ul>
<li>姓名：高辛</li>
<li>身份：黄帝的曾孙，父亲蛟极</li>
<li>特点：生而神灵，自言其名(这肯定是夸张的说法)</li>
<li>儿子：放动和挚</li>
<li>继任者：挚。因为挚是老大，所以得以继任帝位，但是他在位的九年政纪不显著，而放动所在的国家越来越好，因此禅让给了放动。放动也就是尧。</li>
</ul>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><ul>
<li>所谓知子莫若父，但是帝喾看不见尧的贤能而立挚，可见其贤能也不过如是。</li>
</ul>
<h2 id="帝尧"><a href="#帝尧" class="headerlink" title="帝尧"></a>帝尧</h2><h3 id="帝尧的简介"><a href="#帝尧的简介" class="headerlink" title="帝尧的简介"></a>帝尧的简介</h3><ul>
<li>姓名：放动</li>
<li>身份：帝喾之子，帝挚的弟弟</li>
<li>功绩：命人制定了历法，教授了百姓四时耕作。任用鲧去治理洪水。挑选了舜继承王位</li>
<li>继任者：帝舜</li>
</ul>
<h3 id="评论-1"><a href="#评论-1" class="headerlink" title="评论"></a>评论</h3><ul>
<li>尧的识人之能，用人之方比他的父亲强多了。这也可能是他父亲的事给他留下了深刻的教训。自己有儿子丹朱，却不立为帝位，可见后世尊尧为圣人还是有道理的。</li>
<li>尧在用人的时候不仅会有自己的判断，而且听了别人的推荐还会去花时间考察，一步一步的将权利交给别人，这体现了尧用人的谨慎。</li>
</ul>
<h2 id="注解和集字"><a href="#注解和集字" class="headerlink" title="注解和集字"></a>注解和集字</h2><p>惪:同“德”<br>鲧:gǔn,一种很大的鱼</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/二十四史/">二十四史</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二十四史/">二十四史</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/史记/">史记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java_FileClass" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/Java_FileClass/" class="article-date">
      <time datetime="2018-01-15T02:00:00.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java_FileClass/">File类</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="一-File类的概述"><a href="#一-File类的概述" class="headerlink" title="一.File类的概述"></a>一.File类的概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>File更应该叫做一个路径<ul>
<li>文件路径或者文件夹路径  </li>
<li>路径分为绝对路径和相对路径</li>
<li>绝对路径是一个固定的路径,从盘符开始</li>
<li>相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下</li>
</ul>
</li>
<li>查看API<ul>
<li>IO包下</li>
<li>文件和目录路径名的抽象表示形式</li>
</ul>
</li>
<li>B:构造方法<ul>
<li>File(String pathname)：根据一个路径得到File对象，需要注意转义字符</li>
<li>File(String parent, String child):根据一个目录和一个子文件/目录得到File对象</li>
<li>File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象</li>
</ul>
</li>
</ul>
<h2 id="二-File类的功能"><a href="#二-File类的功能" class="headerlink" title="二.File类的功能"></a>二.File类的功能</h2><h3 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h3><ul>
<li>public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了</li>
<li>public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了</li>
<li>public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来</li>
</ul>
<h3 id="File类的重命名和删除功能"><a href="#File类的重命名和删除功能" class="headerlink" title="File类的重命名和删除功能"></a>File类的重命名和删除功能</h3><ul>
<li>A:重命名和删除功能<ul>
<li>public boolean renameTo(File dest):把文件重命名为指定的文件路径</li>
<li>public boolean delete():删除文件或者文件夹</li>
</ul>
</li>
<li>B:重命名注意事项<ul>
<li>如果路径名相同，就是改名。</li>
<li>如果路径名不同，就是改名并剪切。</li>
</ul>
</li>
<li>C:删除注意事项：<ul>
<li>Java中的删除不走回收站。</li>
<li>要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</li>
</ul>
</li>
</ul>
<h3 id="File类的判断功能"><a href="#File类的判断功能" class="headerlink" title="File类的判断功能"></a>File类的判断功能</h3><ul>
<li>public boolean isDirectory():判断是否是目录</li>
<li>public boolean isFile():判断是否是文件</li>
<li>public boolean exists():判断是否存在</li>
<li>public boolean canRead():判断是否可读—–Windows中认为所有的文件都是可读的</li>
<li>public boolean canWrite():判断是否可写</li>
<li>public boolean isHidden():判断是否隐藏</li>
</ul>
<h3 id="File类的获取功能"><a href="#File类的获取功能" class="headerlink" title="File类的获取功能"></a>File类的获取功能</h3><ul>
<li>public String getAbsolutePath()：获取绝对路径</li>
<li>public String getPath():获取构造方法中传入的路径</li>
<li>public String getName():获取文件或文件夹的名称</li>
<li>public long length():获取长度。字节数</li>
<li>public long lastModified():获取最后一次的修改时间，毫秒值</li>
<li>public String[] list():获取指定目录下的所有文件或者文件夹的名称数组</li>
<li>public File[] listFiles():获取指定目录下的所有文件或者文件夹的File对象数组 </li>
</ul>
<h3 id="文件名称过滤器的概述及使用"><a href="#文件名称过滤器的概述及使用" class="headerlink" title="文件名称过滤器的概述及使用"></a>文件名称过滤器的概述及使用</h3><ul>
<li>概述FilenameFilter<ul>
<li>实现此接口的类的实例用于过滤文件名</li>
<li>public String[] list(FilenameFilter filter)</li>
<li>public File[] listFiles(FileFilter filter)</li>
</ul>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA学习/">JAVA学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FilenameFilter/">FilenameFilter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File类/">File类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 John Doe
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>